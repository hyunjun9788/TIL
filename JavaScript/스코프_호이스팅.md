### 전역 스코프, 지역 스코프

```
let x=0;

const scopeTest = function(){
	let y=1;
	console.log(x)
}

console.log(x);
console.log(y);
```

: x는 지역 스코프에서 참조될 수 있다.

:y는 전역 스코프에서 참조될 수 없다.

<br>

### 함수 스코프

- 함수를 실행할 때 생겨나는 지역 스코프

```
let x=0;

const scopeTest = function(){
	let y=1;
	console.log(x)
}

console.log(x);
console.log(y);
```

:  scopeTest 함수로 인해 생성된 스코프로 y라는 변수는 해당 지역 스코프 내에만 존재.

: 블록 레벨 스코프를 따르지 않아 var 키워드만 사용하던 시기에는 지역 스코프 내에 갇히는 변수가 발생하며, 전역 스코프로 해당 변수가 들어가게 되었다.

: 이후 let, const 키워드 등장

<br>



### 블록 스코프

- 코드 블록에 의해 생성되는 스코프
- if문, while문 등 중괄호를 사용해서 코드 블록을 작성하는 환경에서 생성 됨.

```
for (let i =0; i<6; i++){
	let a='123'
	if (i>3){
	let a ="asd"
	console.log(a)
	}
	let b="123"
}
```

: 두 개의 블록 레벨 스코프 존재, for문 내에는 a,b변수 존재

: if 조건문 내부에도 a 변수가 존재하는데 for 블록 레벨 스코프와 if 블록 레벨 스코프는는 서로 다른 영역이므로 서로 영향 X

: let, const 키워드이기 때문에 가능하다.

<br>

```
for (let i=0; i<6; i++){
	let a ="123"
	if (i>3){
	console.log(a)
	}
	let b="123"
}
```

:if 문에의해 성성된 블록 스코프 내에 a라는 변수는 존재하지 않음에도, for 블록 스코프에 존재하는 a변수 참조한다.  why?

<br>

#### 스코프 체이닝

자바스크립트는 변수를 참조하는 코드를 만나게 됐을 때, 먼저 해당하는 블록 스코프 내에서 변수를 참조하려고 시도한다. 존재하지 않으면, 상위 스코프에서 찾아본다.

<br>

### 호이스팅

: 함수, 변수의 선언이 마치 위로 끌어올려진 것처럼 동작하는 것을 의미.

:함수만 지역변수로 호이스팅 되고, 나머지(for,if 등)는 전역변수로 올려버린다.

: javascript는 코드를 실행하기 전, 먼저 선언된 변수, 함수 등을 전역 환경에 담아둔다.

선언단계 : 선언한 변수를 식별자가 담기는 객체에 할당하는 단계 

초기화단계 : 변수에 할당할 메모리 공간을 부여하는 단계 

할당 단계 : 정의된 변수에 데이터가 할당되는 단계

<br>

```
console.log(a)
let a=1
console.log(a)
```

:let은 TDZ존이 있어 a가 선언된 라인 전까지는 a를 사용하지 못함.



<br>
출처: 인프런 훈훈한 JS